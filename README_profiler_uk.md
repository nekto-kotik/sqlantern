# Профілювання запитів в SQLantern
Профілювання запитів як таке - справа не складна і не особлива, але маленькі зручності в SQLantern додають гнучкості: можна профілювати один або багато запитів по колу, змінювати порядок запитів, і пропускати обрані запити.\
Разом із дублюванням панелей і збереженням та відновленням сесій, повторне вимірювання та порівняння швидкості в SQLantern дуже комфортне для розробників і тестувальників.

Запити вимірюються по колу, безкінечно, один за одним (окремо, по черзі), доки профілювання не зупинене.\
Вимірювання починається після натиснення кнопки "Пуск", і зупиняється після натиснення кнопки "Стоп".\
Якщо натиснути "Пуск" знову, _всі вимірювання в цій панелі видаляються_ (процес починається знову; запити, звісно, залишаються на місці).\
Якщо Вам треба разом бачити старі і нові вимірювання, запишіть кудись старі значення, або продублюйте панель із профілюванням, і запустіть нові вимірювання у новій панелі.

Запити виконуються і вимірюються _послідовно, не паралельно, не одночасно_.\
Щоби провести паралельні вимірювання, створіть/дублюйте декілька панелей із профілюванням. Оскільки кожна панель виконується в окремому потоці, профілювання в різних панелях виконується паралельно.

## Профілювання MariaDB/MySQL
### Яке джерело часу в MariaDB/MySQL?
Час, який виводиться - це "Duration" з `SHOW PROFILES`.\
Це внутрішнє вимірювання бази даних, без впливу затримки мережі або інших уповільнень.

### Внутрішній кеш бази даних MariaDB/MySQL
Наскільки мені відомо, в PostgreSQL немає ніяких нюансів із внутрішнім кешем (можливо лише перезапустити систему бази даних; виправте мене, якщо помиляюсь, будь ласка), але в MariaDB/MySQL вони є.\
Підозрюю, що нижченаведена стратегія для InnoDB спрацює в PostgreSQL, але я цього ще не спробував.

Я вважаю корисним і важливим знати як "холодний", так і кешований час виконання запитів, тому нижче описую як їх отримати із двох найбільш розповсюджених двигунів таблиць.

#### Профілювання таблиць MyISAM
Із двигуном таблиць MyISAM все дуже просто: щоби отримати як "холодний", так і закешований час, достатньо вимірювати запит або список запитів із `FLUSH TABLES` спочатку, та без нього:

![](https://sqlantern.com/images/uk_profiler_flush_tables_on_off.jpg)

Але це геть не так просто із двигуном InnoDB, для якого не існує команди очистки його внутрішнього кешу (buffer pool).\
Типічна порада в інтернеті - перезапустити систему бази даних, але я маю іншу рекомендацію.\
Моя ідея багатокрокова, і кроків тим більше, чим більше таблиць треба профілювати, зате процес повністю контрольований і відтворюваний всередині SQLantern.

#### Профілювання таблиць InnoDB
Моя стратегія для вимірювання як "холодного", так і закешованого часу виконання із таблицями InnoDB - це проводити вимірювання в _окремій тимчасовій базі даних_ (наприклад, "tmp_profiling"), яка є копією оригінальної робочої бази даних, і проводити наступні операції _кожного разу, при кожному вимірюванні_:
- Очистити (`TRUNCATE`) таблицю або таблиці _в тимчасовій базі даних_, що використовуються в вимірюваному запиті/запитах
- Скопіювати оригінальні дані в цю тимчасову базу даних (`INSERT/SELECT` із однієї бази даних в іншу, як на скріншоті нижче)
- Запустити запит або запити, "холодний" час яких треба дізнатись

![](https://sqlantern.com/images/uk_profiler_innodb_strats.jpg)

Використання тимчасової бази даних із такими ж таблицями, що й оригінал, дозволяє запускати оригінальні запити без змін.

Наскільки я бачу, цей метод працює дуже добре, і повертає такі ж самі результати, що і "холодна" робота після перезапуску системи бази даних.\
На вищенаведеній ілюстрації ліворуч `TRUNCATE` і `INSERT` виконуються кожного разу перед `SELECT`, повертаючи некешований час, а праворуч `TRUNCATE` і `INSERT` пропускаються, і повертається час виконання із кешем.

## Профілювання в PostgreSQL
### Яке джерело часу в PostgreSQL?
Час, який виводиться - це **сума** "Planning Time" _та_ "Execution Time" з `EXPLAIN (ANALYZE true)`.\
Це внутрішнє вимірювання бази даних, без впливу затримки мережі або інших уповільнень, _окрім випадків, коли перед значеннями стоїть "n/a"_.

Якщо Ви бачите "n/a" перед часом, не довіряйте таким вимірюванням!\
Це означає, що запит несумісний із `EXPLAIN` (наприклад, `TRUNCATE`) і вимірювання було зроблене в PHP, і включає в себе затримку мережі і усі інші внутрішні сповільнення.\
Цей час виводиться, щоби надати бодай якесь приблизне значення, але його треба вважати дуже неточним.

Приклад вимірювань із "n/a" та без:\
![](https://sqlantern.com/images/uk_profiler_postgresql_n_a.jpg)